#类


- 类是模板，对象是由模板创建的实例 
- 一堆对象具有相同的属性和行为，我们就可以抽象出类


- OOP:面向对象编程；OOD：面向对象设计；OOA：面向对象分析；

- 面向对象：把事物的属性对应全局变量，行为就是对象方法；  

- 面向对象的程序是由【对象】组成的


- 由类构造对象的过程称为创建类的实例

**注意：并不是所有的类都具有面向对象的特征：如Math**

###不可变的类：类中的每个方法都不会改变其对象
#类的形式

	【访问修饰符】【修饰符】 class  类名{
		
		访问修饰符：public\default
		修饰符：final\synchronized\abstract
	
	 }
	
###类与类之间的关系
1. 依赖（uses-a）:如果一个类的方法操纵另一个类的对象，我们就说一个类依赖另一个类

		应该尽可能的将相互依赖减至最小，即让类之间的耦合度最小
2. 聚合(has-a)：类A的对象包含类B的对象
3. 继承(is-a)

#对象

- 对象的三个特性

		1、对象的行为：可以对对象施加哪些方法
		2、对象的状态：当施加那些方法时，对象如何响应
		3、对象标识：如何辨别具有相同行为与状态的不同对象
 

##对象与对象变量的区别

	Date date;
	定义了一个对象变量date，它可以引用Date类型的对象，但是date不是一个对象，也没有引用对象，所有不能将任何Date方法应用于这个变量上，（对象必须new）
**注意：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象**

局部变量不会自动的初始化为null，必须通过调用new或者将它们设置为null

**注意：文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公共类，但可以有任意数目的非共有类;如果类不是public，则文件名可以与类不同**

**final修饰的类不能被继承** 


#类之间的关系
1. 关联关系

		属性关系就是关联关系
		就是一个类中的一个属性是另一个类，则这两个类就是关联关系
1. 依赖关系

		方法的参数关系就是依赖关系（getter\setter）
		一个类作为另一个类中方法的参数、方法返回值

#内部类
1. 静态内部类
2. 非静态内部类
3. 局部内部类（方法里）

		public class OuterClass {
	
			private String name;
		
			static class InnerClass1{
				
			}
			private class InnerClass2{
				
				public void ddd() {
					//使用外部类的属性
					System.out.println(OuterClass.this.name);
					
				}
				
			}
			public InnerClass2 getInstence() {
				return new InnerClass2();
			}
			
			public static void main(String[] args) {
				String str="hhhh";
				//静态内部类实例化
				OuterClass.InnerClass1 a=new OuterClass.InnerClass1();
				//非静态内部类实例化：利用公开方法返回非静态内部类
				//先实例化父类，在调用公开方法
				OuterClass ot=new OuterClass();
				OuterClass.InnerClass2 nn=ot.getInstence();
				
				//局部内部类
				class InnerClass3{
					int a=1;
					public void abc() {
						
						System.out.println(a);
						//局部内部类在调用外部的变量时，这个变量必须时常量，即使改变量不写final，（jdk1.8之前final必须写，1.8之后可以不写，但还是常量）
						//如果内部类使用了它，它就会变为常量，无法再修改，出现修改变量的语句就会报错
						//如果内部类没使用这个变量，则这个变量正常
						//str和a都是这样
						System.out.println(str);
						
					}
				}
				
				InnerClass3 aa=new InnerClass3();
				aa.abc();	
			}
			
		}

**内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域**
###为什么要用内部类

1. 内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据

        1、直接使用
        2、外部类.this.属性名

2. 内部类可以对同一个包中的其它类隐藏起来

4. 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷

**只有内部类可以是私有的，其它的类只能是default和public**

内部类使用外围类引用
    
    外围类类名.this

**内部类中声明的所有静态域都必须是final，因为每个外部类的对象，都会分别有一个单独的内部类实例，如果不是final，则这个静态域可能会不一样**

**内部类中不能定义静态方法**

非静态内部类实例化

    先实例化外部类对象
    外部类.内部类=外部类对象.new 内部类（）；

#局部内部类
#####局部内部类不能使用public或private访问修饰符，它的作用域被限定在声明这个局部类的块中。  
#####局部内部类只在其所在块内有效，块外无法访问  
#####局部内部类不仅能够访问包含它们的外部类，还能访问局部变量。不过这些【局部变量】必须事实上为final，即使这个局部变量声明的不是final，在被内部类使用后，其就会变为fianl，不能被修改，如果其在内部类使用之前被修改了，则内部类无法使用这个局部变量。

#匿名内部类
只创建这个类的一个对象，就不用命名了  
内部类不能有构造器，取而代之的是将构造器参数传给父类

#静态内部类
>只有内部类可以被声明为static  
>静态内部类不能访问外部类的属性和对象  
>静态内部类可以有静态域和方法  
>声明在接口中的内部类自动称为static和public  

  
