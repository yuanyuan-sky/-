#Class类
1、在面向对象的世界里，万事万物皆对象  
2、普通数据类型不是面向对象的，但是他们有封装类  
3、静态的成员不是对象的，是类的  
**类也是对象，任何一个类都是是java.lang.Class类的实例对象，这个对象我们称为该类的类类型**

####如果类是对象，那么这个对象怎么标识呢 ？有三种方法 

	class Foo{
		public void print(){
			System.out.prinln("I am Foo")
		}
	}
	Foo foo = new Foo();
	怎么标识Foo这个类呢

1. Class c1 = Foo.class;

		同时也告诉我们，任何一个类都有一个隐含的静态成员:class
2.  已知该类的对象，通过getClass()方法

		Class c2 = foo.getClass();
3.  Class.forName("类的全称")方法

		Class c3 = null;
		c3 = Class.forName("com.reflect.Foo");//会抛异常
**c1 == c2 == c3**  
**不管c1、c2、c3都代表Foo类的类类型，一个类只可能是Class类的一个实例对象**

###通过类类型创建类的实例

	通过c1、c2、c3创建Foo的实例
	Foo f1 =(Foo) c1.newInstance();//需要有无参数的构造方法，调用无参构造方法
	f1.print();

#2动态加载类
#####Class.forName("类的全称");
- 不仅代表了类的类类型，还代表了动态加载类。
- 编译时刻加载类是静态加载类、运行时刻加载类是动态加载类。

**注意区分编译、运行**
- new创建对象是静态加载类，在编译时刻就需要加载所有的可能使用到的类，如果找不到需要的类，则编译报错。

###动态加载
在运行时加载  

	interface OfficeAble{
		public void start();
	}
	------------------------------
	class Excel implements OfficeAble 
	{
		public void start()
		{
			System.out.println("Excel start....");
		}
	}
	--------------------------------
	class  Word implements OfficeAble
	{
		public  void start(){
			System.out.println("word start");
		}
		
	}

	---------------------------------
	public class DynamicClass {
	
		private Class object;
	
		public DynamicClass(Class object) {
			super();
			this.object = object;
		}
		
		public void print() {
			OfficeAble o;
			try {
				o = (OfficeAble) object.newInstance();
				o.start();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		public static void main(String[] args) {
			//这个时候传谁就是调用谁
			DynamicClass d= new DynamicClass(Excel.class);
			d.print();
		}
	}
#获取类的信息
	
	Class c1 = Foo.class;
	c1.getName();//获取Foo类的类全名（包括包名）：com.etc.Foo
	c1.getSimpleName();//获取的是Foo类的类名，不包含报名：Foo

	Class c2 = int.class;c2.getName();//int 
	Class c3 = String.class;c3.getName();//java.lang.String
	Class c4 = Double.class;//c4.getName();//java.lang.Double
	Class c5 = double.class;//c5.getName();//double
	Class c6 = void.class;//c6.getName();//void
#获取方法信息
Method类，方法对象；一个成员方法就是一个Method对象

1. Method[]  getMethods();

		Method[] ms = c1.getMethods();
		获取的是所有public的函数，包括从父类继承过来的
2. Method[]  getDeclareMethods();
 
		Methods[] ms2 = c1.getDeclareMethods();
		获取的是该类自己声明的方法，不问访问权限
3. Class  getReturnType();
	
		获取方法的返回值的类类型
		Class returnType = ms[1].getReturnType();
		获取返回值的类全名
		String a = returnType.getName();
4. Class[] getParameterType();

		Class[] params = ms[1].getParameterTypes();
		获取的是参数类别的类型的类型
		String p = params[1].getName();
		获取第一个参数的类全名
#获取成员变量的信息
成员变量也是对象  
java.lang.reflect.Field  
Field类封装了关于成与变量的操作  
getFields() 获取的是所有public 成员变量的信息  
getDeclaredFields()获取的是该类自己声明的成员变量的信息

	Class c = Foo.class;
	Fields[] fs = c.getDeclaredFields();
	//获取第一个成员变量类型的类类型
	Class a = fs[1].getType()
	String type = a.getName();
	//获取第一个成员变量的变量名
	String fieldName = fs[1].getName()

#获取构造方法的信息
构造函数也是对象  
java.lang.Constructor中封装了构造函数的信息  
getConstructors()获取所有public的构造函数  
getDeclaredConstructors();得到所有的构造函数  

	Class c = Foo.class;
	Constructors[] cs = c.getDeclaredConstructors();
	获取构造方法的方法名
	cs[1].getName();
	获取构造方法的参数列表的类类型
	Class[] params = cs[1].geteParameterTypes();
	params[1].getName();//获取第一个参数类型的类类型

#方法的反射
1. 如何获取某个方法

	方法的名称和方法的参数列表才能唯一决定某个方法
1. 方法的反射操作

	method.invoke(对象，参数列表);//参数列表有则写，没有则不写

----------


	public Demo{
		public static void main(String[] args) {
			
			//获取A的对象
			A a1 = new A();
			//获取A的类类型
			Class c = A.class;
			/**
			*getMethod();//获取public的方法
			*getDeclaredMethod();//获取自己声明的方法
			*/	
			//获取带有两个int参数的print方法的Method对象
			Method m = c.getMethod("print",int.class,int.class);
			//调用m方法；效果与 a1.print(10,20)是一样的
			//o是返回值，没有返回值则是Null，有返回值则返回具体的值
			//如果是静态方法，只需要将第一个参数设为null即可
			Object o = m.invock(a1,10,20);
			
			Method m1 = c.getMethod("print",String.class,String.class);
			m1.invock(a1."hello","world");

			Method m3 = c.getMethod("print");
			m3.invock(a1);
			
		
		}

	}
	------------------------------------------------------
	class A {
		public void print(int a, int b) {
			System.out.println(a + b);
		}
	
		public void print(String a, String b) {
			System.out.println(a.toUpperCase()+","+b.toUpperCase());
		}
		
		public void print() {
			System.out.println("hello world");
		}
	}
	
#泛型的本质

	public static void main(String[] args) {
		ArrayList list1 = new ArrayList();	
		ArrayList<String> list2 = new ArrayList<String>();
		list1.add("hello");
		//报错，添加不进去
		//list2.add(20);
		
		Class c1 = list1.getClass();
		Class c2 = list2.getClass();
		//反射的操作都是在编译之后的
		//返回true说明编译之后集合的泛型是去泛型
		//Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了
		//通过方法的反射绕过编译
		System.out.println(c1 == c2);
		
		try {
			Method m = c2.getMethod("add", Object.class);
			//添加进去了
			m.invoke(list2, 20);
			System.out.println(list2.size());
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		
	}


