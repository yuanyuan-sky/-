#数据类型
只有两种：1.基本类型 2：对象类型  
##8种基本类型：


1. 数值类型：分为整数和浮点型

		1.byte  字节    8位    -128~127      -2的7次方~2的7次方减1             字节：网络传输最小单位，文件大小计量
		
		2.short  短整型    2字节      16位    【淘汰了】

		3.int    整形      4字节      32位  
  
		**整数字面量默认都是int**

		4.long   长整形    8字节      64位    int放不下时用long

当long也放不下时，使用BigInteger对象
	
		BigInteger big1=new BigInteger("7777777777777777777777777777777");

##.浮点型基本数据类型
		
	5.float  :单精度浮点数   4字节    32位   默认比int大

	6.double  双精度浮点数     8字节   64位 （在double存不下的时候用BigDecimal）
同位数的类型，浮点型默认比整型大   
        42e1  ==420.0---- double类型


**浮点型默认字面量都是double**  
  
**JAVA没有===**

**注意：浮点型不要参与运算（会丢失精度）**  

	7.boolean :布尔型  true/false    1位

	java中 0不等于false

	8.char   字符型  用单引号  2字节    16位

char型和整型可以隐式转换，char参与运算，当整型用


char  16位  2个字节    半角字符是1个字节，全角字符是2个字节（ASCII码是半角）

Java中的char数据类型采用 unicode编码方式，占2字节

#转译字符
	制表符(就是tab键): \t
	换行：\n
	回车：\r
	\  : \\
	'  : \'
	"  : \"
	
#对象的属性
	属性：类的全局变量（非static）

java7开始，可以为数字字面量加下划线

	1_000_000  表示1000000（下划线只是让人更易读，java编译器会去除这些下划线）

#变量
1. 变量是内存中的一块存储区域，是存储数据的基本单元

1. 变量的命名：字母、下划线、美元符号($)开头，后面可以跟数字、字母、下划线、美元符号（$）
2. 变量名对大小写敏感
3. 只能声明一次，可以多次赋值

#标识符
1、数字、字母、下划线、美元符号（$）  
2、数字不能开头  
3、严格区分大小写  
4、标识符可以为任意长度

##变量的使用
1. 声明
2. 赋值
3. 使用

**三个步骤缺一不可**  



1. 全局变量（成员变量）：定义在类中  
		
		全局变量可以不赋值就使用，因为它有默认值，和数组的默认值一样

1. 局部变量：定义在方法中

		局部变量【必须】赋值才可以使用 ，声明的时候可以不赋值，但是使用的时候必须有值才能使用 
**全局变量可以使用四种修饰符和static，局部变量不可以使用，局部变量也不能使用static，final都可以使用**
###变量的作用域
全局变量的在整个类中都可以用 ，如果访问权限允许，还可以在类外部使用   
局部变量只能在当前方法可以作用

###注意
1. 局部变量在同一个方法内不可以重复，在不同的方法中可以有重名的变量 
2. 全局变量可以和局部变量重名
3. 如果全局变量和局部变量重名，方法内优先使用的是局部变量
	
#ASCII码
		
 半角范围，键盘上的。拉丁字母0~128

十进制48   对应字符   '0'   
	 65				'A'  
	 97				'a'  

#unicode码  全角字符
通过\u开头的16进制 定义的字符

	char a='\u9A6C';
	解决文档的全角乱码

#注意：
1. 基本类型运算 ，结果的类型按大的位数的类型确定

	1/2=0  
	1/2.0=0.5

##大小关系 
	byte-short-int-long-float-double
1. 自动类型转换：小类型给大类型赋值，结果会自动变成大类型（隐式转换）

		int a=100;
		a*=1.25; a=125;
		为什么结果不是double类型呢？
		在【赋值运算符】中，如果结果的类型与左边的类型不一样的时候，就会发生强制转换，把结果转成左边的类型
		a=a*1.25;这样就会报错，需要进行显示转换
2. 强制类型转换：大类型给小类型赋值	（显示转换）

**注意：强制转换可能会丢失精度**
	
	byte a;
	short b=128;      0000 0000 1000 0000
	a=b;      byte只有8位，会把前面的8位截掉 剩10000000 就是-128


![avatar](..\imgs\1.png) 


**上图中，虚线代表可能有精度损失的转换，实现是没有精度损失的转换**

#运算符

1. 算术运算符

		一元运算符：-（负号） 、++、--   ；  自增自减只能用于变量   4++；是不合法的，报错。
		 
		二元运算符：+、-、*、/、%

1. 关系（比较）运算符

		> 、<、>=、<= 、!= 、==

1. 逻辑运算符
  
		一元 ：    ! 
		二元：  ||、&&、|、&
		|| 短路或，前面为真。后面不计算
		&& 短路与、前面为假、后面不计算
		| 和 & 不发生短路

1. 条件运算符

		三元表达式：表达式1 ? 表达式2 ：表达式3

1. 赋值运算符

		=、+=、-=、*=、/=、%=

###运算符的优先级

	1：（）、[]
	2：一元运算符：-、++(前置)、--(后置)、！
	3：算术运算符：+、-、*、/、%
	4：关系运算符：>、>=、<、<=、==、!==
	5：逻辑运算符：&、|、&&、||
	6：条件运算符（三元）
	7：赋值运算符：=、*=、+=、-=、/=、%=

#进制
	
	0b开头：二进制
	0开头：八进制
	0x开头：十六进制

#位移运算
1. <<左移  (左移几位，相当于乘以2的几次方)

		8 << 1         16
1. `>>`右移 （右移几位，相当于除以2的几次方）
		
		8 >> 1          4
负数位移：先求负数的补码，将其补码进行移动，然后补1，然后再转成源码 ；整数位移是补0 
**移动发生溢出时，则溢出的会截断**
1. `>>>`  无符号位右移
无符号数：没有符号位 ，就是有【符号数】的符号为变成了计数位 

		不论是正数还是负数，都是将其右移，然后高位补0，（低位溢出，高位补0）
**无符号右位移只对32位和64位有意义**

#控制台输入
	
	Scanner sc=new Scanner(System.in);
	下面这句会造成线程堵塞。直到输入一个整型数据
	int a=sc.nextInt();//获取控制台输入的整形数
	double b=sc.nextDouble();//获取控制台输入的double	
	sc.close();
使用 hasNext 与 hasNextLine 判断是否还有输入的数据 ,hasNextInt...    
next  与nextLine的返回值是String 
**nextLine()与next()的区别**  
1. next()

	1、一定要读取到有效字符后才可以结束
	2、对于输入有效字符之前有空白，next()方法会自动将其去掉
	3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符
	4、next()不能得到带有空格的字符串
1. nextLine()  
	
		1、以enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符
		2、可以获得空白
###Scaner的坑
当在其它的输入类型后面跟nextLine时  

		Scanner s=new Scanner(System.in);
		System.out.print("输入第一个数：");
		int a=s.nextInt();
		System.out.println("请输入第二个数：");
		String b=s.nextLine();
		System.out.println("输入的数是："+a+"---"+b);
![avatar](..\imgs\2.png)  
可以看到nextLine自动读取了nextInt后的enter符作为他的结束符，所以没办法输入b。其它的next。。。方法【后面】使用nextLine都是这样。  
**解决方法**  
如果非要在后面写nextLine的话，写两个nextLine，第一个nextLine用来过滤掉上面的next的enter符

		s.nextLine();
		String b=s.nextLine();


#switch case
	switch(表达式){
		case 常量:
		break;
		default:
	}
	表达式：jdk1.7之前，只能是小于等于int的类型，（byte,char,int,short,枚举）
	**注意：1.7之前case后面只能跟常量**
	1.8：表达式可以是字符串，case后面可以用字符串；
	当表达式为字符串时，case后面只能是字符串  
	常量的类型必须与表达式的类型一致，即使这个常量不可能匹配

#数组与集合
※js中没有集合的概念  
1. 什么是java数组 

		数组是用于将相同类型的数据存储在【连续】的存储单元中；其它语言的数组也是连续存储
1.  数组在声明的时候不会分配空间，这样可以有效的防止内存泄漏，内存过界，保证了程序的健壮性，提升内存使用效率；所有的变量在声明时都不会分配内存，赋值和实例化才会分配内存。

		int []a;  // 声明数组
		a=new int[10]; //分配空间（初始化）
		int b=new int[10];  //声明数组并分配空间
1. 数组的下标是int型
###获取数组的长度
	
	array.length;后面没有（）
	数组的长度可以是一个已经有值的整型变量
###定义数组的三种方式


1. int[] a1=new int[n]; a1[0]=....  
2. int[]   a2={1,2,3,4};
3. int a[]; a=new int[n]; 或者 a=new int[]{1,2,3,4}
3. int a3[]=new int[]{1,2,3,4};  **注意：这种声明方式，,两个中括号必须写，但后面的中括号中不能写东西** int a[]=new int[4]{1，2，3，4}  【这是错误的声明方式】



**[] 的位置可以在数组名前，也可以在数组名后，二位数组可以一个在数组名前，一个在后**  
	int[] a;
	int a[]


**注意:数组声明是使可以不指定大小,但实例化（初始化、实现）的时候必须指定大小；集合可以不指定**    
**java中允许数组的长度为0，数组长度为0与null不同**

**已定义的数组无法改变大小**  
**数组复制不能用==，因为==是将数组的地址赋给了另外一个；==两边的数组类型必须一样**

		int a[]= {1,2,3,4};
		int b[]=new int[4];
		b=a;
		a[0]=66;         //b[0]也变成了66
		for(int i=0;i<4;i++) {
			System.out.println(b[i]);
		}
		这时候只是将a的地址赋给了b，其实a和b对应的都是堆中的同一个数组，不算数组的复制
		-----------------------------------
		int a[];
		int b[]={1,2,3,4}
		a=b;
		这样也是合法的，a获取的数组的地址
###数组的默认值
	1、byte                      0
	2、short                     0        
	3、int类型定义的数组，初始化默认是0
	4、long                       0
	5、float                      0.0
	6、double                      0.0
	7、boolean		              false
	8、char                        ASCII码0对应的字符 ==\u0000
	9、String                      null	
	
###集合的定义
	
	list<E> a4=new ArrayList<E>();
	集合中的元素不能是基本类型。只能是对象类型
##数组工具类Arrays


1. sort(数组)；数组排序，默认升序

		Arrays.sort(数组);
        sort(Object[] a);
        对数组a进行排序，要求数组中的元素必须属于实现了Comparable接口的类，并且元素之间是可比较的
1. Arrays.copyOf(原数组，个数)；返回一个新数组

		原数组里从开始位置取n个元素，返回一个新数组
1. Arrays.copyOfRange(原数组，起始位置，终止位置);

		截取数组，返回一个新数组，范围是左闭右开
1. System.arrayCopy(原数组，原数组的起始位置，新数组，新数组的起始位置，原数组中要取的个数)
2. Arrays.toString(a)

		将a数组转变为字符串，会保留逗号和[]
		int[] a = new int[]{1,2,3,4};
		System.out.println(Arrays.toString(a));
		"[1,2,3,4]"

1. Arrays.binarySearch(a,b)

		在数组a中查找b，查找成功返回b在a中的下标，否则返回一个负数r（负数是如果把b插入中，使a还能保持有序的下标,-r-1等于那个下标）
		a必须是已经排好序的数组，a的类型不能是string，是8中基本类型
		b必须是与a中元素类型相同的值，

1. Arrays.binarySearch(a,int start,int end,b);

		与上面的相同，只是多了查找的开始和结束的位置（左闭右开）
1. Arrays.fill(a,b)   --改变原数组

		将数组a的所有元素设置为b
		a:8种基本类型的数组
		b:与a中的数据类型相同的一个值
1. Arrays.equals(a,b)

		如果两个数组大小相同，并且下标相同的元素对应都相等，返回true，否则为false
		a,b:8种基本类型的数组
###二维数组


1. 二维数组的声明方式

		1、int a[][];  a=new int[m][n];    
		2、int a[][]=new int[m][n];
			**上面两种情况下n可以不写，但是m必须写**
		3、int a[][]={{1,2},{2,3}};
		4、int a[][]=new int[][]{{1,2,3},{2,4}}
**注意数组在同时声明和赋值的时候，右边的方括号中不能写东西**   
**二位数组每行的元素个数可以不一样**   
**注意【左边】两个中括号的位置可以随意写**
		
		int a[][];   int  [][]a   int []a[];  都可以
1. 一个for each不能循环出二位数组的每个元素，如果想用for each循环每一个元素，需要两个循环嵌套

		for(int[] item : array){     //不要忘了int后面的[]
	
			item是每一行的元素，也是个数组  
		}

		-----------------------------------

		for(int[] item :array){
			
			for(int i : item){
				i才是每一个元素
			}

		}
1. 如果想快速的打印二维数组，可以调用 deepToString();

		int a[][] = new int[][] { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		System.out.println(Arrays.deepToString(a));
		"[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"
	
	

#循环
1. for each

		int[] a = new int[]{1,2,3,4};
		for (int i : a) {
			System.out.println(i);
		}
循环内部【声明】的变量只在循环内有效，循环外无法访问，同样，循环变量i也只在循环内有效。
  
		for (int i = 0; i < 10000; ++i) {
		  Object obj = new Object();
		  System.out.println("obj= "+ obj);
		} 
		在第i次循环，生成对象o1，但当此次循环结束的时候，o1就被GC回收了，所以第i+1次循环生成的o2与第i次没有任何关系；每次循环结束都会回收对象。
		===============================================
		Object obj = null;

		for (int i = 0; i < 10000; ++i) {
		  obj = new Object();
		  System.out.println("obj= "+ obj);
		} 
		第i次循环生成对象o1，但此次循环结束的时候，o1不会被GC回收；当第i+1次循环生成了对象o2，此时o1没有引用，会被GC回收，但此次循环结束，o2不会被回收；最后一次循环生成的对象在循环全部结束不会被回收，若想回收则需要将obj再次赋为null

#引用数据类型


1. 在java中，除了8中基本数据类型外，其余的全部都属于引用引用数据类型【虽然String不属于8种基本类型，但是String按基本类型的规则传递值】
2. 存储在引用类型变量中的值是该变量表示的值的地址

#跳转语句
- break：跳出本次循环（跳出整个循环语句块）
- continue:跳出本层循环
- return：跳出方法
- 带标签的break：标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号（尽量不要用）
- 
		abc:
		while(...){

			for(..){
				if(..){
					break anc;
				}
			}

		}
		这样可以直接跳出while循环
		-----------------------------------
		标签可以应用到任何语句中，例如if，块语句中
		lable:
		{
		
			break lable;
		}
**只能跳出，不能跳入**

#大数值
1. BigInteger类：实现了任意精度的整数运算
2. BigDecimal类：实现了任意精度的浮点数的运算

使用静态的valueOf()方法可以将普通的数值转换为大数值  
	

	BigInteger big=BigInteger.valueOf(123);
	BigDecimal a=BigDecimal.valueOf(1.2);
大数值不能使用 + 、-、*、/运算符，要使用响应的方法  
1. .add();求和  
2. .subtract();求差  
3. .multiply();求积  
4. .divide();求商；在计算BigDecimal类型的时候比较特殊，查看API  
5. .mod();求余数；BigDecimal类型不能用；  
6. compareTo();比较两个大数值是否相等，相等返回0，不等返回差值（外面的减去括号内的）  
7. valueOf(long x);返回值等于x的大数值;BigDecimal类使用，在（）里放入double类型  
8. valueOf(long x,int scale);BigDecimal类使用，返回x/10<sup>scale</sup>

###对于BigDecimal类
	add()可以指定精度:MathContext.DEXIMAL32  7位  /   64   16位   /  128   34位         
	BigDecimal b1.add(b2,MathContext.DEXIMAL128);
	其它运算也可以用
.setScale();设置精确位数

		BigDecimal  b3=b1.setScale(n);  b3精确n位
		注意：如果b3本身是0.35，则n要大于等于2，也就是n要大于等于b3的小数个数，也就是说这个方法不能舍掉小数


###三元表达式

    ((x > 4) ? 99.99 : 9)；//结果是9.0；  99.99是double类型，结果转为double

###数值相等只能用==，不能用equals























		
		
	


	
	
