#继承的初始化顺序
1. 初始化父类，再初始化子类
2. 先执行初始化对象中属性，再执行构造方法中的初始化  

![avatar](..\imgs\999.jpg)   

#继承
通过扩展一个类来建立另外一个类的过程称为继承，子类会获得父类的属性和方法  
1. 子类不能直接访问父类的私有变量，虽然子类也含有父类的私有变量，如果子类要使用这个私有变量，就必须通过父类公开的getter、setter方法。但是对于父类的公共属性，可以使用子类.属性访问。

	子类.getName()；//获取从父类继承过来的私有name属性

2. 如果子类覆盖（override）了父类的方法，而子类又要使用父类的这个方法，就要使用super.方法名

		super.方法名（）；

**super不是一个对象的引用，不能将super赋给另一个对象变量** 

1. 子类可以增加变量、增加方法、覆盖（override）父类的方法。绝不能删除父类的变量和方法  

**java不支持多继承**
#子类构造器
在子类构造器中调用的super();是调用父类中与之匹配的构造方法，通常是对父类中的私有变量进行初始化，但不是new一个父类对象，super语句必须位于构造器中的第一句。  
**如果子类的构造器没有显式的调用父类的构造器，则将自动的调用超类默认的构造器（没有参数的构造器）。如果超类没有不带参数的构造器，并且子类的构造器又没有显示的调用父类的其它构造器，则java编译器报错（子类构造器中必须调用父类的构造器）**

**子类可以存放进父类类型的数组里，但是父类不能存进子类类型的数组里，虽然可以通过强转，编译时不会报错，但是运行时会报错；父类类型可以存子类类型，子类类型不能存父类类型**   
**子类的属性可以和父类的一样，不会覆盖，都有效**


#单继承多实现


1. 一个类只能继承一个类
1. 所有的类都是object的子类



#覆盖（方法的覆盖）override
**属性不是覆盖**    
  
###方法覆盖的原则  
	同名
	同参
	同返回值（PPT）
	权限修饰符只能放大不能缩小
    异常只能是父类的异常，或者父类异常的子类（父类不抛出异常，子类也不能抛异常；父类抛异常子类一定要抛）   
	实际上返回值不一定相同，允许子类将覆盖方法的返回类型定义为原返回类型的子类

**重写就是覆盖**overLoad/override


**继承并不限于一个层次**  
由一个公共超类派生出来的所有类的集合被称为继承层次  
从某个特定的类到其祖先的路径被称为该类的继承链  

**子类能继承父类的私有方法和属性，但是不能直接使用，私有属性可以通过父类的公开方法获得，私有方法无法使用**

**子类无法继承父类的静态变量和静态方法，但是在子类中可以直接使用，也可以子类点父类的静态方法和变量，也可以父类点静态方法和变量**

**静态方法不能构成覆盖，静态是属于类的，即使子类和父类有相同的方法，他们属于各自的类**

**类A中有一个方法abc()，类B继承A类,如果类B没有覆盖类A中的abc方法，则在类B中，super.abc（）与this.abc结果一样；但是如果类B覆盖了类A的abc方法，则super.abc()指的是类A中的abc方法，而this.abc指的是类B覆盖的方法abc（）**

	
	